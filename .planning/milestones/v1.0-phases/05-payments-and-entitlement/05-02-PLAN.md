---
phase: 05-payments-and-entitlement
plan: 02
type: execute
wave: 2
depends_on: [05-01]
files_modified:
  - src/app/(main)/dashboard/page.tsx
  - src/components/dashboard/MyLibrary.tsx
  - src/components/dashboard/LibraryBookCard.tsx
autonomous: false
requirements: [AUTH-03]
user_setup: []

must_haves:
  truths:
    - "User can view all purchased books in My Library section on the dashboard"
    - "Each library card shows book title, author, cover image, and a link to read"
    - "My Library shows empty state when user has no purchases"
    - "Books are ordered by most recently purchased first"
  artifacts:
    - path: "src/components/dashboard/MyLibrary.tsx"
      provides: "My Library section with book cards or empty state"
      contains: "MyLibrary"
    - path: "src/components/dashboard/LibraryBookCard.tsx"
      provides: "Individual book card for purchased books"
      contains: "LibraryBookCard"
    - path: "src/app/(main)/dashboard/page.tsx"
      provides: "Dashboard page with populated My Library"
      contains: "getUserPurchases"
  key_links:
    - from: "src/app/(main)/dashboard/page.tsx"
      to: "src/lib/purchase-queries.ts"
      via: "getUserPurchases server-side call"
      pattern: "getUserPurchases"
    - from: "src/components/dashboard/MyLibrary.tsx"
      to: "src/components/dashboard/LibraryBookCard.tsx"
      via: "maps purchases to cards"
      pattern: "LibraryBookCard"
---

<objective>
My Library dashboard integration and end-to-end purchase flow verification

Purpose: Purchased books appear in the user's dashboard in a My Library section, completing the purchase-to-library loop. The existing EmptyLibrary placeholder is replaced with a populated grid when purchases exist. A human verification checkpoint confirms the entire flow end-to-end.

Output: My Library component with book cards on the dashboard, populated from the Purchase + Book join query created in Plan 01.
</objective>

<execution_context>
@/Users/roh/.claude/get-shit-done/workflows/execute-plan.md
@/Users/roh/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-payments-and-entitlement/05-RESEARCH.md
@.planning/phases/05-payments-and-entitlement/05-01-SUMMARY.md
@src/app/(main)/dashboard/page.tsx
@src/components/dashboard/EmptyLibrary.tsx
@src/lib/purchase-queries.ts
@src/components/catalog/BookCoverImage.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: My Library component and dashboard integration</name>
  <files>
    src/app/(main)/dashboard/page.tsx
    src/components/dashboard/MyLibrary.tsx
    src/components/dashboard/LibraryBookCard.tsx
  </files>
  <action>
    **1. Create `src/components/dashboard/LibraryBookCard.tsx` — individual book card:**

    Server component (no "use client").

    Props interface matching the shape returned by `getUserPurchases` — each purchase has a `book` with `{ id, title, slug, authorName, coverImage }` plus `createdAt` from the Purchase record.

    ```typescript
    interface LibraryBookCardProps {
      book: {
        id: string;
        title: string;
        slug: string;
        authorName: string;
        coverImage: string | null;
      };
      purchasedAt: Date;
    }
    ```

    Render a `<Card>` (from shadcn) wrapped in `<Link href={/read/${book.slug}}>`:
    - Cover image area: Use the `BookCoverImage` component from `@/components/catalog/BookCoverImage` (already handles null covers with gradient fallback). Wrap it in an `aspect-[2/3]` container with `relative overflow-hidden rounded-t-lg` and reasonable max height.
    - Card body (inside CardContent with `p-4`):
      - Book title: `<h3>` with `font-serif font-semibold text-sm line-clamp-2`
      - Author name: `<p>` with `text-xs text-muted-foreground mt-1`
    - The whole card should have `hover:shadow-md transition-shadow` and `group` class for hover effects.
    - Keep it compact — this is a grid card, not a detail view.

    **2. Create `src/components/dashboard/MyLibrary.tsx` — library section with cards or empty state:**

    Server component.

    Props: `purchases` array matching the return type of `getUserPurchases`.

    Import `EmptyLibrary` from `@/components/dashboard/EmptyLibrary` and `LibraryBookCard`.

    Render:
    - Section heading: `<h2 className="font-serif text-xl font-semibold text-foreground mb-4">My Library</h2>`
    - If `purchases.length === 0`, render `<EmptyLibrary />` (the existing empty state — keep using it as-is, just without the heading since MyLibrary provides it). Actually, EmptyLibrary already has its own heading. To avoid duplication: conditionally render — if no purchases, render `<EmptyLibrary />` directly (which includes its own heading). If purchases exist, render the heading + grid.
    - If purchases exist: `<div className="grid grid-cols-2 sm:grid-cols-3 lg:grid-cols-4 gap-4">` mapping purchases to `<LibraryBookCard>` components.

    Wait — looking at EmptyLibrary, it has its own `<h2>My Library</h2>` heading. To keep things clean:
    - When purchases exist: render `<div>` with `<h2>My Library</h2>` heading + grid of cards
    - When no purchases: render `<EmptyLibrary />` (which already has the heading)
    This avoids modifying EmptyLibrary.tsx.

    **3. Modify `src/app/(main)/dashboard/page.tsx` — integrate My Library:**

    Import `getUserPurchases` from `@/lib/purchase-queries` and `MyLibrary` from `@/components/dashboard/MyLibrary`.

    After the session check, fetch purchases:
    ```typescript
    const purchases = await getUserPurchases(session.user.id);
    ```

    Replace the grid layout. Currently:
    ```tsx
    <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
      <EmptyLibrary />
      <EmptyRecentlyRead />
    </div>
    ```

    Change to:
    ```tsx
    <MyLibrary purchases={purchases} />
    <div className="mt-6">
      <EmptyRecentlyRead />
    </div>
    ```

    My Library gets the full width (not constrained to half the grid) since the book card grid is responsive. EmptyRecentlyRead moves below.

    Remove the `EmptyLibrary` import from the dashboard page since `MyLibrary` handles the empty state internally.
  </action>
  <verify>
    1. `npm run build` completes without type errors
    2. `grep -r "getUserPurchases" src/app/(main)/dashboard/page.tsx` confirms dashboard fetches purchases
    3. `grep -r "LibraryBookCard" src/components/dashboard/MyLibrary.tsx` confirms card rendering
    4. `grep -r "EmptyLibrary" src/components/dashboard/MyLibrary.tsx` confirms empty state fallback
  </verify>
  <done>
    - Dashboard page fetches user's purchases server-side via getUserPurchases
    - MyLibrary component renders book cards in a responsive grid when purchases exist
    - MyLibrary falls back to existing EmptyLibrary empty state when no purchases
    - LibraryBookCard shows cover image (with fallback), title, and author, linked to /read/{slug}
    - Books are ordered by most recently purchased first (query order from purchase-queries.ts)
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 2: Verify complete purchase flow end-to-end</name>
  <what-built>Complete Stripe checkout and payment flow: Buy button on detail page, Stripe Checkout redirect, webhook-driven access grant, success page, receipt email, My Library population, and open-access book treatment.</what-built>
  <how-to-verify>
    **Prerequisites:**
    1. Ensure PostgreSQL is running and migrations are applied
    2. Set STRIPE_SECRET_KEY (test key) and STRIPE_WEBHOOK_SECRET in .env
    3. Run `stripe listen --forward-to localhost:3000/api/webhooks/stripe` in a terminal
    4. Start dev server: `npm run dev`

    **Test 1: Unauthenticated user sees "Sign In to Purchase"**
    1. Visit a paid book detail page (e.g., `/catalog/[slug]`) while NOT logged in
    2. Verify: Button reads "Sign In to Purchase" and links to `/sign-in?redirect=/catalog/[slug]`
    3. Verify: Open-access books show "Read Free" button instead

    **Test 2: Purchase flow (happy path)**
    1. Sign in to a test account
    2. Visit a paid book detail page
    3. Verify: Buy button shows "Buy — $XX.XX"
    4. Click Buy — should redirect to Stripe Checkout
    5. Use test card 4242 4242 4242 4242 (any future expiry, any CVC)
    6. Complete payment
    7. Verify: Redirected to `/purchase/success` page showing "Purchase Complete" with book title and "Start Reading" button
    8. Verify: Stripe CLI terminal shows webhook received and processed
    9. Click "Start Reading" — should open the reader

    **Test 3: Already-purchased state**
    1. Return to the same book's detail page
    2. Verify: Buy button is now "Read Now" (not another Buy button)

    **Test 4: My Library**
    1. Visit `/dashboard`
    2. Verify: My Library section shows the purchased book with cover, title, and author
    3. Click the book card — should open the reader

    **Test 5: Receipt email**
    1. Check Resend dashboard (or test email inbox) for the purchase confirmation email
    2. Verify: Email has book title, price, purchase date, "Start Reading" link, and download reminder

    **Test 6: Open-access book**
    1. Visit an open-access book detail page
    2. Verify: Shows green "Open Access" badge and "Read Free" button (no buy button)
    3. Click "Read Free" — opens reader without needing a purchase
  </how-to-verify>
  <resume-signal>Type "approved" if all tests pass, or describe any issues found.</resume-signal>
</task>

</tasks>

<verification>
1. Dashboard shows My Library with purchased books or empty state for new users
2. Book cards link correctly to `/read/{slug}`
3. Full purchase flow works end-to-end: catalog -> buy -> Stripe -> success -> reader -> library
4. Open-access books remain freely accessible without purchase
5. Receipt email delivered with correct content
</verification>

<success_criteria>
- User can view all purchased books in My Library section on dashboard
- My Library shows empty state with "Browse Catalog" CTA for users with no purchases
- The entire purchase-to-library flow works end-to-end as verified by human testing
</success_criteria>

<output>
After completion, create `.planning/phases/05-payments-and-entitlement/05-02-SUMMARY.md`
</output>
