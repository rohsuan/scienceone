---
phase: 14-blog
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/app/(main)/blog/[slug]/page.tsx
  - src/app/sitemap.ts
autonomous: true
requirements:
  - BLOG-03
  - BLOG-04
  - BLOG-05
  - BLOG-06
  - BLOG-07

must_haves:
  truths:
    - "A published blog post page includes a JSON-LD Article schema with datePublished always present (never undefined)"
    - "A published blog post page includes Open Graph meta tags with title, description, type: article"
    - "Blog post HTML content is passed through sanitizeHtml() before dangerouslySetInnerHTML"
    - "Blog post code blocks are Shiki-highlighted (highlightCodeBlocks applied before sanitizeHtml)"
    - "GET /sitemap.xml returns XML with URLs for published blog posts, resources, and simulations"
    - "Visitor can browse /blog and filter by category and subject"
    - "Visitor can search /blog by keyword"
  artifacts:
    - path: "src/app/(main)/blog/[slug]/page.tsx"
      provides: "Blog detail page with JSON-LD fix and Shiki highlighting"
      contains: "highlightCodeBlocks"
    - path: "src/app/sitemap.ts"
      provides: "Sitemap covering blog posts, resources, and simulations"
      contains: "MetadataRoute.Sitemap"
  key_links:
    - from: "src/app/(main)/blog/[slug]/page.tsx"
      to: "src/lib/highlight-code.ts"
      via: "highlightCodeBlocks called on post.content before sanitizeHtml"
      pattern: "highlightCodeBlocks.*content"
    - from: "src/app/(main)/blog/[slug]/page.tsx"
      to: "src/lib/sanitize-html.ts"
      via: "sanitizeHtml wraps highlighted content in dangerouslySetInnerHTML"
      pattern: "sanitizeHtml.*highlightedContent"
    - from: "src/app/sitemap.ts"
      to: "src/lib/prisma.ts"
      via: "Prisma queries for published blog posts, resources, and simulations"
      pattern: "prisma\\.blogPost\\.findMany"
---

<objective>
Fix blog SEO metadata, add Shiki code highlighting, create sitemap, and verify public blog listing

Purpose: The blog detail page has a JSON-LD bug (datePublished silently drops when publishedAt is null), lacks code syntax highlighting, and no sitemap exists for the entire site. This plan fixes the SEO metadata, adds Shiki highlighting for code blocks in blog posts, creates a comprehensive sitemap covering blog posts, resources, and simulations, and verifies the existing public listing/search/filter functionality.

Output: Fixed blog detail page with complete JSON-LD Article schema, Shiki-highlighted code blocks, and a new sitemap.ts serving all published content URLs.
</objective>

<execution_context>
@/Users/roh/.claude/get-shit-done/workflows/execute-plan.md
@/Users/roh/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/14-blog/14-RESEARCH.md

Reference files:
@src/app/(main)/blog/[slug]/page.tsx (current blog detail — needs JSON-LD fix + Shiki)
@src/app/(main)/blog/page.tsx (public listing — verify only)
@src/lib/highlight-code.ts (highlightCodeBlocks utility — already exists)
@src/lib/sanitize-html.ts (sanitizeHtml utility — already exists)
@src/lib/blog-queries.ts (public queries — verify only)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Fix JSON-LD datePublished and add Shiki code highlighting to blog detail page</name>
  <files>src/app/(main)/blog/[slug]/page.tsx</files>
  <action>
Two changes to the blog detail page:

**1. Fix JSON-LD datePublished fallback (line 57):**

Change:
```typescript
datePublished: post.publishedAt?.toISOString(),
```
to:
```typescript
datePublished: (post.publishedAt ?? post.createdAt).toISOString(),
```

This ensures `datePublished` is always a string in the JSON-LD output. When publishedAt is null, it falls back to createdAt. `JSON.stringify` will never silently drop it.

Also fix the `description` field (line 52) — change `post.excerpt ?? undefined` to `post.excerpt ?? ""` so the description key is always present in JSON-LD (empty string is valid, undefined is silently dropped):
```typescript
description: post.excerpt ?? "",
```

**2. Add Shiki code highlighting:**

Add import at the top:
```typescript
import { highlightCodeBlocks } from "@/lib/highlight-code";
```

In the `BlogPostPage` component, after fetching the post and before the JSX return, add:
```typescript
const highlightedContent = post.content
  ? await highlightCodeBlocks(post.content)
  : null;
```

Update the content rendering section (around line 143) from:
```typescript
{post.content && (
  <article
    className="prose prose-neutral dark:prose-invert max-w-none prose-headings:font-serif"
    dangerouslySetInnerHTML={{ __html: sanitizeHtml(post.content) }}
  />
)}
```
to:
```typescript
{highlightedContent && (
  <article
    className="prose prose-neutral dark:prose-invert max-w-none prose-headings:font-serif"
    dangerouslySetInnerHTML={{ __html: sanitizeHtml(highlightedContent) }}
  />
)}
```

Order is critical: `highlightCodeBlocks` first (transforms `<pre><code>` to Shiki HTML), then `sanitizeHtml` (allows Shiki class/style attributes through). The existing sanitize-html config already allows `class` on `code` and `style` on `*`.
  </action>
  <verify>Read the modified file and confirm: (1) `highlightCodeBlocks` is imported, (2) datePublished uses `(post.publishedAt ?? post.createdAt).toISOString()`, (3) `highlightedContent` variable is computed with `await highlightCodeBlocks(post.content)`, (4) dangerouslySetInnerHTML uses `sanitizeHtml(highlightedContent)` not `sanitizeHtml(post.content)`.</verify>
  <done>JSON-LD datePublished always has a value; blog post code blocks are Shiki-highlighted before sanitization</done>
</task>

<task type="auto">
  <name>Task 2: Create sitemap covering blog posts, resources, and simulations</name>
  <files>src/app/sitemap.ts</files>
  <action>
Create `src/app/sitemap.ts` — the Next.js App Router sitemap file convention. This file MUST be at the app root (not inside a route group).

```typescript
import type { MetadataRoute } from "next";
import prisma from "@/lib/prisma";

const BASE_URL = process.env.NEXT_PUBLIC_APP_URL ?? "https://scienceone.com";

export default async function sitemap(): Promise<MetadataRoute.Sitemap> {
  const [blogPosts, resources, simulations] = await Promise.all([
    prisma.blogPost.findMany({
      where: { isPublished: true },
      select: { slug: true, updatedAt: true },
    }),
    prisma.resource.findMany({
      where: { isPublished: true, type: { not: "SIMULATION" } },
      select: { slug: true, updatedAt: true },
    }),
    prisma.resource.findMany({
      where: { isPublished: true, type: "SIMULATION" },
      select: { slug: true, updatedAt: true },
    }),
  ]);

  const staticRoutes: MetadataRoute.Sitemap = [
    { url: `${BASE_URL}/`, changeFrequency: "weekly", priority: 1.0 },
    { url: `${BASE_URL}/blog`, changeFrequency: "daily", priority: 0.9 },
    { url: `${BASE_URL}/resources`, changeFrequency: "daily", priority: 0.9 },
    { url: `${BASE_URL}/simulations`, changeFrequency: "weekly", priority: 0.8 },
    { url: `${BASE_URL}/catalog`, changeFrequency: "weekly", priority: 0.8 },
  ];

  return [
    ...staticRoutes,
    ...blogPosts.map((post) => ({
      url: `${BASE_URL}/blog/${post.slug}`,
      lastModified: post.updatedAt,
      changeFrequency: "monthly" as const,
      priority: 0.8,
    })),
    ...resources.map((r) => ({
      url: `${BASE_URL}/resources/${r.slug}`,
      lastModified: r.updatedAt,
      changeFrequency: "monthly" as const,
      priority: 0.7,
    })),
    ...simulations.map((s) => ({
      url: `${BASE_URL}/simulations/${s.slug}`,
      lastModified: s.updatedAt,
      changeFrequency: "monthly" as const,
      priority: 0.7,
    })),
  ];
}
```

Key details:
- Simulations are Resources with `type: "SIMULATION"` — their public URL is `/simulations/{slug}`, NOT `/resources/{slug}`
- Non-simulation resources use `/resources/{slug}`
- Only published content (`isPublished: true`) is included
- `NEXT_PUBLIC_APP_URL` is already set in `.env.local`
- The function is `async` and returns `Promise<MetadataRoute.Sitemap>`
- Default export named `sitemap` per Next.js convention
  </action>
  <verify>Read `src/app/sitemap.ts` and confirm: (1) file exists at app root (not inside a route group), (2) queries filter `isPublished: true`, (3) simulations use `type: "SIMULATION"` and `/simulations/` URL path, (4) non-simulation resources use `type: { not: "SIMULATION" }` and `/resources/` URL path, (5) blog posts use `/blog/` URL path. Run `npx tsc --noEmit` to verify no type errors.</verify>
  <done>Sitemap at /sitemap.xml serves URLs for all published blog posts, non-simulation resources, and simulations with correct paths</done>
</task>

</tasks>

<verification>
1. `grep -n "highlightCodeBlocks" src/app/\\(main\\)/blog/\\[slug\\]/page.tsx` — confirms Shiki integration
2. `grep -n "publishedAt.*createdAt" src/app/\\(main\\)/blog/\\[slug\\]/page.tsx` — confirms datePublished fallback
3. `grep -n "sanitizeHtml" src/app/\\(main\\)/blog/\\[slug\\]/page.tsx` — confirms sanitization still in place (BLOG-06)
4. `cat src/app/sitemap.ts` — confirms sitemap exists at app root with blog + resources + simulations
5. `grep -n "isPublished: true" src/app/sitemap.ts` — confirms only published content in sitemap
6. `npx tsc --noEmit` — no type errors
7. Verify blog listing page (`src/app/(main)/blog/page.tsx`) passes searchParams for category, subject, q, sort to query — already confirmed correct in research (BLOG-03, BLOG-04)
</verification>

<success_criteria>
- JSON-LD Article schema always has datePublished (falls back to createdAt)
- Blog post code blocks are Shiki-highlighted before sanitizeHtml
- sanitizeHtml is still applied to all blog post content (BLOG-06 preserved)
- /sitemap.xml includes published blog posts, resources (non-simulation), and simulations with correct URL paths
- No TypeScript errors
- Blog listing page correctly handles category, subject, and search filters (verified by code inspection)
</success_criteria>

<output>
After completion, create `.planning/phases/14-blog/14-02-SUMMARY.md`
</output>
