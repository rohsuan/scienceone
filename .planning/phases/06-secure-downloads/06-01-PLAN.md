---
phase: 06-secure-downloads
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/r2.ts
  - src/app/api/download/route.ts
  - src/app/layout.tsx
  - src/components/catalog/DownloadButton.tsx
  - src/components/catalog/DownloadDropdown.tsx
  - src/app/(main)/catalog/[slug]/page.tsx
autonomous: true
requirements: [DL-01, DL-02, DL-03]

must_haves:
  truths:
    - "Authenticated user with purchase can download PDF via time-limited presigned URL"
    - "Authenticated user with purchase can download EPUB via time-limited presigned URL"
    - "Unauthenticated or unpurchased request to /api/download returns 401 or 403"
    - "Open-access books allow download with session only (no purchase required)"
    - "Print purchase link appears in the book metadata section (near ISBN/pages/dimensions)"
    - "Download error toasts display correctly via sonner Toaster"
  artifacts:
    - path: "src/lib/r2.ts"
      provides: "Shared R2 client for presigned URL generation"
      contains: "createR2Client"
    - path: "src/app/api/download/route.ts"
      provides: "GET handler with auth + entitlement + presign + audit log"
      exports: ["GET"]
    - path: "src/components/catalog/DownloadButton.tsx"
      provides: "Client component for individual PDF/EPUB download button"
      contains: "DownloadButton"
    - path: "src/components/catalog/DownloadDropdown.tsx"
      provides: "Client component dropdown for compact download placements"
      contains: "DownloadDropdown"
  key_links:
    - from: "src/components/catalog/DownloadButton.tsx"
      to: "/api/download"
      via: "fetch with bookSlug + format params"
      pattern: "fetch.*api/download"
    - from: "src/app/api/download/route.ts"
      to: "src/lib/r2.ts"
      via: "createR2Client + getSignedUrl"
      pattern: "getSignedUrl"
    - from: "src/app/(main)/catalog/[slug]/page.tsx"
      to: "src/components/catalog/DownloadButton.tsx"
      via: "conditional render based on pdfKey/epubKey + access"
      pattern: "DownloadButton"
---

<objective>
Create the presigned URL download API route, shared R2 client, DownloadButton and DownloadDropdown client components, wire downloads onto the book detail page, relocate the print link to the metadata section, and mount the Toaster for error feedback.

Purpose: Enables authenticated users with access to download PDF and EPUB files via secure, time-limited URLs. Establishes the reusable download components that Plan 02 wires into the remaining placements (library card, reader header).

Output: Working download flow on the book detail page; reusable DownloadButton and DownloadDropdown components; print link in correct metadata position.
</objective>

<execution_context>
@/Users/roh/.claude/get-shit-done/workflows/execute-plan.md
@/Users/roh/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-secure-downloads/06-RESEARCH.md
@.planning/phases/05-payments-and-entitlement/05-01-SUMMARY.md
@scripts/lib/r2-upload.ts
@src/app/api/reading-progress/route.ts
@src/app/(main)/catalog/[slug]/page.tsx
@src/lib/purchase-queries.ts
@src/app/layout.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: R2 client, download API route, and Toaster mount</name>
  <files>
    src/lib/r2.ts
    src/app/api/download/route.ts
    src/app/layout.tsx
  </files>
  <action>
**1. Create `src/lib/r2.ts`** — Extract the R2 client pattern from `scripts/lib/r2-upload.ts` for use in app code.

```typescript
import { S3Client } from "@aws-sdk/client-s3";

export function createR2Client(): S3Client {
  return new S3Client({
    region: "auto",
    endpoint: `https://${process.env.R2_ACCOUNT_ID!}.r2.cloudflarestorage.com`,
    credentials: {
      accessKeyId: process.env.R2_ACCESS_KEY_ID!,
      secretAccessKey: process.env.R2_SECRET_ACCESS_KEY!,
    },
    // CRITICAL: R2 does not support CRC32 checksums — causes 400 errors without this
    requestChecksumCalculation: "WHEN_REQUIRED",
    responseChecksumValidation: "WHEN_REQUIRED",
  });
}
```

**2. Create `src/app/api/download/route.ts`** — GET route handler with this exact flow:

a. **Auth check:** `const session = await auth.api.getSession({ headers: await headers() })` — return 401 JSON if no session.

b. **Parse params:** Read `bookSlug` and `format` from `request.url` searchParams. Validate `format` is `"pdf"` or `"epub"` — return 400 if invalid. Validate `bookSlug` is non-empty — return 400 if missing.

c. **Rate limiting:** Use an in-memory Map keyed by `${session.user.id}:${bookSlug}:${format}`. Allow 10 requests per user per book per format per 60 seconds. Return 429 JSON `{ error: "Too many requests" }` if exceeded. Implementation:
```typescript
const downloadRequests = new Map<string, { count: number; resetAt: number }>();

function checkRateLimit(key: string, maxRequests = 10, windowMs = 60_000): boolean {
  const now = Date.now();
  const record = downloadRequests.get(key);
  if (!record || now > record.resetAt) {
    downloadRequests.set(key, { count: 1, resetAt: now + windowMs });
    return true;
  }
  if (record.count >= maxRequests) return false;
  record.count++;
  return true;
}
```

d. **Fetch book:** `prisma.book.findUnique({ where: { slug: bookSlug, isPublished: true }, select: { id, slug, title, pdfKey, epubKey, isOpenAccess } })` — return 404 if not found.

e. **Entitlement check:** If `!book.isOpenAccess`, look up Purchase: `prisma.purchase.findUnique({ where: { userId_bookId: { userId: session.user.id, bookId: book.id } }, select: { id: true } })` — return 403 JSON `{ error: "Purchase required" }` if no purchase.

f. **Artifact check:** `const key = format === "pdf" ? book.pdfKey : book.epubKey` — return 404 JSON `{ error: "File not available" }` if key is null.

g. **Generate presigned URL:**
```typescript
import { GetObjectCommand } from "@aws-sdk/client-s3";
import { getSignedUrl } from "@aws-sdk/s3-request-presigner";

const contentType = format === "pdf" ? "application/pdf" : "application/epub+zip";
const url = await getSignedUrl(
  createR2Client(),
  new GetObjectCommand({
    Bucket: process.env.R2_BUCKET_NAME!,
    Key: key,
    ResponseContentDisposition: `attachment; filename="${book.slug}.${format}"`,
    ResponseContentType: contentType,
  }),
  { expiresIn: 900 }
);
```

h. **Audit log (fire-and-forget):** `void prisma.download.create({ data: { userId: session.user.id, bookId: book.id, format } })` — do NOT await.

i. **Return:** `NextResponse.json({ url })`.

Use `NextResponse` from `next/server` (consistent with existing API routes).

**3. Mount Toaster in `src/app/layout.tsx`:**
- Import `Toaster` from `@/components/ui/sonner`
- Add `<Toaster />` as a sibling of `{children}` inside `<body>`, right after `{children}`
- This enables `toast.error()` feedback from DownloadButton across all routes (root layout wraps all route groups)

**Important:**
- Do NOT use `<a download>` anywhere — does not work cross-origin with R2 presigned URLs
- Do NOT expose pdfKey/epubKey in the JSON response — only return `{ url }`
- Do NOT await the audit log — fire-and-forget
- Use `auth.api.getSession({ headers: await headers() })` pattern exactly as in existing routes
  </action>
  <verify>
    - `npx next build` passes (no type errors, no import errors)
    - `src/lib/r2.ts` exists and exports `createR2Client`
    - `src/app/api/download/route.ts` exists and exports `GET`
    - `src/app/layout.tsx` contains `<Toaster />`
  </verify>
  <done>
    - R2 client module exists with WHEN_REQUIRED checksum config
    - Download API route handles: auth (401), validation (400), rate limit (429), entitlement (403), missing artifact (404), and presigned URL generation (200 with `{ url }`)
    - Toaster mounted in root layout for toast feedback across all pages
  </done>
</task>

<task type="auto">
  <name>Task 2: Download components, detail page integration, and print link relocation</name>
  <files>
    src/components/catalog/DownloadButton.tsx
    src/components/catalog/DownloadDropdown.tsx
    src/app/(main)/catalog/[slug]/page.tsx
  </files>
  <action>
**1. Create `src/components/catalog/DownloadButton.tsx`** — Client component for individual format download (used on detail page where space is available for separate PDF/EPUB buttons).

```typescript
"use client";

import { useState } from "react";
import { toast } from "sonner";
import { Download } from "lucide-react";
import { Button } from "@/components/ui/button";

interface DownloadButtonProps {
  bookSlug: string;
  format: "pdf" | "epub";
  label?: string;
  variant?: "outline" | "secondary" | "ghost";
  size?: "sm" | "default";
  className?: string;
}

export default function DownloadButton({
  bookSlug,
  format,
  label,
  variant = "outline",
  size = "sm",
  className,
}: DownloadButtonProps) {
  const [loading, setLoading] = useState(false);

  async function handleDownload() {
    setLoading(true);
    try {
      const res = await fetch(
        `/api/download?bookSlug=${encodeURIComponent(bookSlug)}&format=${format}`
      );
      if (!res.ok) {
        const data = await res.json();
        toast.error(data.error ?? "Download failed");
        return;
      }
      const { url } = await res.json();
      window.location.href = url;
    } catch {
      toast.error("Download failed. Please try again.");
    } finally {
      setLoading(false);
    }
  }

  return (
    <Button
      variant={variant}
      size={size}
      disabled={loading}
      onClick={handleDownload}
      className={className}
    >
      <Download className="h-4 w-4 mr-1.5" />
      {loading ? "Preparing..." : (label ?? `Download ${format.toUpperCase()}`)}
    </Button>
  );
}
```

**2. Create `src/components/catalog/DownloadDropdown.tsx`** — Client component dropdown for compact placements (library card, reader header). Uses existing DropdownMenu from `@/components/ui/dropdown-menu`.

```typescript
"use client";

import { useState } from "react";
import { toast } from "sonner";
import { Download, FileText, BookOpen } from "lucide-react";
import { Button } from "@/components/ui/button";
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu";

interface DownloadDropdownProps {
  bookSlug: string;
  hasPdf: boolean;
  hasEpub: boolean;
  variant?: "outline" | "secondary" | "ghost";
  size?: "sm" | "default" | "icon";
  label?: string;
}

export default function DownloadDropdown({
  bookSlug,
  hasPdf,
  hasEpub,
  variant = "outline",
  size = "sm",
  label,
}: DownloadDropdownProps) {
  const [loading, setLoading] = useState(false);

  async function handleDownload(format: "pdf" | "epub") {
    setLoading(true);
    try {
      const res = await fetch(
        `/api/download?bookSlug=${encodeURIComponent(bookSlug)}&format=${format}`
      );
      if (!res.ok) {
        const data = await res.json();
        toast.error(data.error ?? "Download failed");
        return;
      }
      const { url } = await res.json();
      window.location.href = url;
    } catch {
      toast.error("Download failed. Please try again.");
    } finally {
      setLoading(false);
    }
  }

  if (!hasPdf && !hasEpub) return null;

  return (
    <DropdownMenu>
      <DropdownMenuTrigger asChild>
        <Button variant={variant} size={size} disabled={loading}>
          <Download className="h-4 w-4 mr-1.5" />
          {loading ? "Preparing..." : (label ?? "Download")}
        </Button>
      </DropdownMenuTrigger>
      <DropdownMenuContent align="end">
        {hasPdf && (
          <DropdownMenuItem onClick={() => handleDownload("pdf")}>
            <FileText className="h-4 w-4 mr-2" />
            Download PDF
          </DropdownMenuItem>
        )}
        {hasEpub && (
          <DropdownMenuItem onClick={() => handleDownload("epub")}>
            <BookOpen className="h-4 w-4 mr-2" />
            Download EPUB
          </DropdownMenuItem>
        )}
      </DropdownMenuContent>
    </DropdownMenu>
  );
}
```

**3. Update `src/app/(main)/catalog/[slug]/page.tsx`** to add download buttons and relocate print link:

a. **Add download buttons** in the left column pricing area. Show download buttons ONLY when user has access (purchased or open-access). Insert below the existing Read/Buy buttons, before the Read Sample button. For the detail page, use two separate `DownloadButton` components (not a dropdown — space is available in the left column).

Conditional rendering logic:
- If `book.isOpenAccess` AND `session`: show download buttons for available formats
- If `purchased` (paid book, user has purchased): show download buttons for available formats
- Otherwise: do NOT show download buttons (buttons are hidden, not disabled — per discretion choice)

Pass `bookSlug` and `format` to DownloadButton. Conditionally render each button only if the corresponding key exists: `book.pdfKey` for PDF, `book.epubKey` for EPUB. This means the `getBookBySlug` query in `book-queries.ts` does NOT need modification — the detail page can do a lightweight additional query or we add pdfKey/epubKey to the existing `getBookBySlug` include. Simpler: update the existing `getBookBySlug` to also select `pdfKey` and `epubKey` in `src/lib/book-queries.ts`. Actually — per RESEARCH.md Pitfall 3, the API route does its own query. But for the detail page, we need to know whether to SHOW the buttons. The simplest approach: add `pdfKey` and `epubKey` to the `getBookBySlug` return. These are just String? fields that are already on the Book model. **Update `src/lib/book-queries.ts`** `getBookBySlug` to include `pdfKey: true` and `epubKey: true` in the select. Since `getBookBySlug` uses `include` (not `select`), all Book scalar fields are already returned — pdfKey and epubKey are already included. So no query change is needed. Just use `book.pdfKey` and `book.epubKey` in the template.

Download buttons section (insert after the conditional pricing buttons, before Read Sample):
```tsx
{/* Download buttons — only for users with access */}
{((book.isOpenAccess && session) || purchased) && (book.pdfKey || book.epubKey) && (
  <div className="flex flex-col gap-2">
    {book.pdfKey && (
      <DownloadButton bookSlug={book.slug} format="pdf" />
    )}
    {book.epubKey && (
      <DownloadButton bookSlug={book.slug} format="epub" />
    )}
  </div>
)}
```

b. **Relocate print link** from the left column pricing area to the right column metadata section. Remove the existing print link block from the left column `<div className="flex flex-col gap-2">` (lines 117-126). Add it to the metadata `<dl>` grid in the right column (near ISBN, pages, dimensions). Style as a text link with external link icon:

```tsx
{book.printLink && (
  <>
    <dt className="font-medium text-foreground">Print Edition</dt>
    <dd>
      <a
        href={book.printLink}
        target="_blank"
        rel="noopener noreferrer"
        className="text-primary underline underline-offset-4 hover:text-primary/80 inline-flex items-center gap-1"
      >
        Buy Print Edition
        <ExternalLink className="h-3 w-3" />
      </a>
    </dd>
  </>
)}
```

Import `ExternalLink` from `lucide-react`.

Also need to update the metadata section condition to include `book.printLink`:
Change `{(book.isbn || book.pageCount || book.dimensions) && (` to `{(book.isbn || book.pageCount || book.dimensions || book.printLink) && (`

c. **Add imports** at top of detail page:
- `import DownloadButton from "@/components/catalog/DownloadButton";`
- `import { ExternalLink } from "lucide-react";`

**Important: Do NOT modify `src/lib/book-queries.ts`** — `getBookBySlug` uses `include` which returns all scalar fields, so `pdfKey` and `epubKey` are already available on the returned book object.
  </action>
  <verify>
    - `npx next build` passes
    - `src/components/catalog/DownloadButton.tsx` exists with "use client" directive
    - `src/components/catalog/DownloadDropdown.tsx` exists with "use client" directive
    - `src/app/(main)/catalog/[slug]/page.tsx` contains `DownloadButton` import and render
    - Print link is in the metadata section (right column `<dl>` grid), not in the left column pricing area
    - Book detail page does NOT show download buttons for unauthenticated users
    - Book detail page does NOT show download buttons for unpurchased paid books
  </verify>
  <done>
    - DownloadButton (separate format buttons) and DownloadDropdown (compact dropdown) components created
    - Book detail page shows PDF/EPUB download buttons for users with access (purchased or open-access + logged in)
    - Book detail page hides download buttons for unauthenticated and unpurchased users
    - Print link relocated from left column pricing area to right column metadata section (near ISBN, pages, dimensions) per locked decision
    - Print link styled as text link with external link icon, no price shown, hidden when not configured
  </done>
</task>

</tasks>

<verification>
1. `npx next build` succeeds without errors
2. Download API route exists at `src/app/api/download/route.ts` and exports GET
3. DownloadButton and DownloadDropdown components exist in `src/components/catalog/`
4. Book detail page conditionally renders download buttons based on access
5. Print link is in the metadata section, not the pricing area
6. Toaster is mounted in root layout
7. R2 client module exists at `src/lib/r2.ts`
</verification>

<success_criteria>
- Authenticated user with purchase can hit /api/download?bookSlug=X&format=pdf and receive a JSON response with { url } containing a presigned R2 URL
- Unauthenticated request to /api/download returns 401
- Unpurchased request to /api/download returns 403
- Open-access book with session returns presigned URL (no purchase required)
- Missing artifact returns 404
- Rate-limited requests return 429
- Book detail page shows download buttons only for users with access
- Print link appears in metadata section per locked decision
- Toast errors display when download fails
</success_criteria>

<output>
After completion, create `.planning/phases/06-secure-downloads/06-01-SUMMARY.md`
</output>
