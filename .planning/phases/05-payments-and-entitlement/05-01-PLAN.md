---
phase: 05-payments-and-entitlement
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - package.json
  - .env.example
  - src/lib/stripe.ts
  - src/lib/checkout-actions.ts
  - src/lib/purchase-queries.ts
  - src/components/catalog/BuyButton.tsx
  - src/app/(main)/catalog/[slug]/page.tsx
  - src/app/(main)/purchase/success/page.tsx
  - src/app/api/webhooks/stripe/route.ts
  - src/emails/PurchaseConfirmation.tsx
autonomous: true
requirements: [PAY-01, PAY-02, PAY-03, PAY-04, AUTH-04]
user_setup:
  - service: stripe
    why: "Payment processing for book purchases"
    env_vars:
      - name: STRIPE_SECRET_KEY
        source: "Stripe Dashboard -> Developers -> API keys -> Secret key (use test key sk_test_...)"
      - name: STRIPE_WEBHOOK_SECRET
        source: "Run `stripe listen --forward-to localhost:3000/api/webhooks/stripe` and copy the whsec_... value it prints"
    dashboard_config:
      - task: "Install Stripe CLI for local webhook testing"
        location: "brew install stripe/stripe-cli/stripe && stripe login"
  - service: app_url
    why: "Stripe checkout success/cancel URLs need the app's base URL"
    env_vars:
      - name: NEXT_PUBLIC_APP_URL
        source: "Set to http://localhost:3000 for local dev (already used by auth but not in .env.example)"

must_haves:
  truths:
    - "User can click Buy on a paid book detail page and be redirected to Stripe Checkout"
    - "After Stripe payment, webhook creates a Purchase record and user gains reader access"
    - "Paying twice for the same book does not create duplicate Purchase records"
    - "Open-access books show 'Read Free' on detail page and remain readable without purchase"
    - "User sees a dedicated success page after purchase with 'Start Reading' button"
    - "User receives a purchase confirmation email with book title, price, date, and reading link"
    - "Unauthenticated users see 'Sign In to Purchase' instead of Buy button"
  artifacts:
    - path: "src/lib/stripe.ts"
      provides: "Stripe SDK singleton instance"
      contains: "new Stripe"
    - path: "src/lib/checkout-actions.ts"
      provides: "createCheckoutSession Server Action"
      exports: ["createCheckoutSession"]
    - path: "src/components/catalog/BuyButton.tsx"
      provides: "Client-side Buy button calling Server Action"
      contains: "use client"
    - path: "src/app/(main)/purchase/success/page.tsx"
      provides: "Post-purchase success page with Start Reading CTA"
      contains: "Start Reading"
    - path: "src/app/api/webhooks/stripe/route.ts"
      provides: "Stripe webhook handler with idempotent Purchase upsert"
      exports: ["POST"]
    - path: "src/emails/PurchaseConfirmation.tsx"
      provides: "React Email purchase receipt template"
      contains: "PurchaseConfirmationEmail"
  key_links:
    - from: "src/components/catalog/BuyButton.tsx"
      to: "src/lib/checkout-actions.ts"
      via: "Server Action import"
      pattern: "createCheckoutSession"
    - from: "src/lib/checkout-actions.ts"
      to: "src/lib/stripe.ts"
      via: "stripe.checkout.sessions.create"
      pattern: "stripe\\.checkout\\.sessions\\.create"
    - from: "src/app/api/webhooks/stripe/route.ts"
      to: "prisma.purchase"
      via: "idempotent upsert on webhook event"
      pattern: "prisma\\.purchase\\.upsert"
    - from: "src/app/api/webhooks/stripe/route.ts"
      to: "src/emails/PurchaseConfirmation.tsx"
      via: "Resend email send after upsert"
      pattern: "resend\\.emails\\.send"
    - from: "src/app/(main)/catalog/[slug]/page.tsx"
      to: "src/components/catalog/BuyButton.tsx"
      via: "conditional render based on purchase + auth state"
      pattern: "BuyButton|Sign In to Purchase|Read Free|Read Now"
---

<objective>
Stripe checkout flow, webhook-driven access grant, and purchase confirmation email

Purpose: Enable readers to purchase paid books via Stripe Checkout, with access reliably granted by webhook (not redirect), and a receipt email sent upon successful payment. This is the critical payment path — the foundation that My Library (Plan 02) builds on.

Output: Stripe SDK integration, checkout Server Action, Buy button on detail page, webhook handler with idempotent Purchase upsert, success page, and purchase confirmation email template.
</objective>

<execution_context>
@/Users/roh/.claude/get-shit-done/workflows/execute-plan.md
@/Users/roh/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-payments-and-entitlement/05-RESEARCH.md
@src/lib/auth.ts
@src/lib/reader-queries.ts
@src/lib/book-queries.ts
@src/app/(main)/catalog/[slug]/page.tsx
@src/emails/verification.tsx
@prisma/schema.prisma
@.env.example
</context>

<tasks>

<task type="auto">
  <name>Task 1: Stripe SDK, checkout Server Action, Buy button, success page, and detail page integration</name>
  <files>
    package.json
    .env.example
    src/lib/stripe.ts
    src/lib/checkout-actions.ts
    src/lib/purchase-queries.ts
    src/components/catalog/BuyButton.tsx
    src/app/(main)/catalog/[slug]/page.tsx
    src/app/(main)/purchase/success/page.tsx
  </files>
  <action>
    **1. Install Stripe SDK:**
    ```bash
    npm install stripe
    ```
    Do NOT install `@stripe/stripe-js` or `@stripe/react-stripe-js` — this uses Stripe-hosted checkout (redirect), not embedded Elements.

    **2. Add env vars to .env.example:**
    Append to `.env.example`:
    ```
    STRIPE_SECRET_KEY=sk_test_xxxxxxxxxxxx
    STRIPE_WEBHOOK_SECRET=whsec_xxxxxxxxxxxx
    NEXT_PUBLIC_APP_URL=http://localhost:3000
    ```

    **3. Create `src/lib/stripe.ts` — Stripe singleton:**
    ```typescript
    import Stripe from "stripe";
    export const stripe = new Stripe(process.env.STRIPE_SECRET_KEY!);
    ```
    No `apiVersion` pin needed — stripe-node 20.x uses the latest at release time.

    **4. Create `src/lib/purchase-queries.ts` — purchase helper queries:**
    Export `hasPurchasedBySlug(userId, bookSlug)` using React `cache()` — checks if a Purchase record exists for the user+book combination by joining through Book.slug. This is needed by the detail page (which has slug, not bookId).
    Also export `getUserPurchases(userId)` — returns all completed purchases with book details (id, title, slug, authorName, coverImage), ordered by `createdAt: "desc"`. This will be used by Plan 02 for My Library.

    **5. Create `src/lib/checkout-actions.ts` — Server Action:**
    `"use server"` directive at top.
    Export `createCheckoutSession(bookId: string)`:
    - Check auth via `auth.api.getSession({ headers: await headers() })` — if no session, `redirect("/sign-in")`
    - Fetch book + pricing from DB: `prisma.book.findUnique({ where: { id: bookId, isPublished: true }, include: { pricing: true } })` — NEVER trust client-sent prices
    - If book not found or no active pricing, throw error
    - Check if already purchased: `prisma.purchase.findUnique({ where: { userId_bookId: { userId: session.user.id, bookId } } })` — if exists, `redirect(\`/read/${book.slug}\`)`
    - Create Stripe checkout session with:
      - `mode: "payment"`
      - `customer_email: session.user.email` (prefills Stripe form)
      - `line_items`: single item with `price_data` (currency "usd", `unit_amount: Math.round(Number(book.pricing.amount) * 100)`, product_data with book title and author description)
      - `metadata: { userId: session.user.id, bookId: book.id, bookSlug: book.slug, userEmail: session.user.email }`
      - `success_url: \`${process.env.NEXT_PUBLIC_APP_URL}/purchase/success?session_id={CHECKOUT_SESSION_ID}\``
      - `cancel_url: \`${process.env.NEXT_PUBLIC_APP_URL}/catalog/${book.slug}\``
    - `redirect(checkoutSession.url!)`

    **6. Create `src/components/catalog/BuyButton.tsx` — client component:**
    `"use client"` directive.
    Props: `{ bookId: string; price: number }` (price is display-only).
    Use `useTransition` from React: `const [isPending, startTransition] = useTransition()`.
    Render a `<Button>` from shadcn:
    - `onClick` calls `startTransition(() => createCheckoutSession(bookId))`
    - `disabled={isPending}`
    - `className="w-full"`
    - Text: `isPending ? "Redirecting to checkout..." : \`Buy — $${price.toFixed(2)}\``

    **7. Modify `src/app/(main)/catalog/[slug]/page.tsx` — add purchase state and Buy button:**
    Import `auth` from `@/lib/auth`, `headers` from `next/headers`, `hasPurchasedBySlug` from `@/lib/purchase-queries`, `BuyButton` from `@/components/catalog/BuyButton`.

    In `BookDetailPage`:
    - Fetch session: `const session = await auth.api.getSession({ headers: await headers() })`
    - Check purchase: `const purchased = session ? await hasPurchasedBySlug(session.user.id, book.slug) : false`

    Replace the Pricing section in the left column (`{/* Pricing */}` div with `flex flex-col gap-2`) with conditional rendering:
    - **Open-access books:** Show the existing green "Open Access" badge PLUS a "Read Free" Button linking to `/read/${book.slug}` (full-width, variant="default")
    - **Paid + already purchased:** Show price text (existing) PLUS a "Read Now" Button linking to `/read/${book.slug}` (full-width, variant="default")
    - **Paid + not purchased + authenticated:** Show price text (existing) PLUS `<BuyButton bookId={book.id} price={Number(book.pricing.amount)} />`
    - **Paid + not purchased + not authenticated:** Show price text (existing) PLUS a "Sign In to Purchase" Button linking to `/sign-in?redirect=/catalog/${book.slug}` (full-width, variant="default")

    Keep the "Read Sample" button and "Buy Print Edition" link below in all cases.

    **8. Create `src/app/(main)/purchase/success/page.tsx` — success page (LOCKED DECISION: dedicated page with "Start Reading" button):**
    Server Component. Import `stripe` from `@/lib/stripe`, `notFound` from `next/navigation`, `Button` from shadcn, `Link` from `next/link`.

    Props: `searchParams: Promise<{ session_id?: string }>`. Await searchParams per Next.js 16 pattern.

    If no `session_id`, call `notFound()`.

    Retrieve session: `stripe.checkout.sessions.retrieve(session_id, { expand: ["line_items"] })`.
    If `session.payment_status !== "paid"`, call `notFound()`.

    Extract `bookSlug` from `session.metadata?.bookSlug` and `bookTitle` from `session.line_items?.data[0]?.description`.

    Render centered layout (`max-w-md mx-auto px-4 py-16 text-center`):
    - Checkmark icon (green circle with checkmark, or use lucide-react `CheckCircle2`)
    - `<h1>` "Purchase Complete" (font-serif text-3xl font-bold)
    - "You now have full access to:" text
    - Book title (font-serif text-xl font-semibold)
    - "A receipt has been sent to {email}" small text
    - `<Button asChild size="lg"><Link href={\`/read/${bookSlug}\`}>Start Reading</Link></Button>`

    Add `export const metadata` with title "Purchase Complete | ScienceOne".
  </action>
  <verify>
    1. `npm run build` completes without type errors
    2. `grep -r "createCheckoutSession" src/lib/checkout-actions.ts` returns the Server Action
    3. `grep -r "use client" src/components/catalog/BuyButton.tsx` confirms client component
    4. `grep -r "hasPurchasedBySlug" src/lib/purchase-queries.ts` confirms helper exists
    5. `grep -r "Start Reading" src/app/(main)/purchase/success/page.tsx` confirms success page content
  </verify>
  <done>
    - `src/lib/stripe.ts` exports Stripe singleton
    - `src/lib/checkout-actions.ts` exports `createCheckoutSession` Server Action that creates Stripe session with price_data and redirects
    - `src/components/catalog/BuyButton.tsx` is a client component with loading state
    - Book detail page conditionally renders Buy / Read Now / Sign In to Purchase / Read Free based on auth + purchase + access state
    - Success page retrieves Stripe session, displays book title, and shows "Start Reading" button
    - .env.example has STRIPE_SECRET_KEY, STRIPE_WEBHOOK_SECRET, NEXT_PUBLIC_APP_URL
    - `stripe` package installed in package.json
  </done>
</task>

<task type="auto">
  <name>Task 2: Stripe webhook handler with idempotent Purchase upsert and purchase confirmation email</name>
  <files>
    src/app/api/webhooks/stripe/route.ts
    src/emails/PurchaseConfirmation.tsx
  </files>
  <action>
    **1. Create `src/emails/PurchaseConfirmation.tsx` — receipt email template (LOCKED DECISION: professional, minimal tone):**

    Follow the EXACT same pattern and style system as `src/emails/verification.tsx`. Reuse the same style constants (body, container, header, logo, content, heading, paragraph, buttonContainer, button, smallText, divider, footer, footerText) — copy them from verification.tsx for consistency.

    Interface: `PurchaseConfirmationEmailProps { bookTitle: string; bookSlug: string; amount: number; purchaseDate: Date; appUrl: string; }`

    Email structure:
    - `<Preview>`: "Your ScienceOne purchase: {bookTitle}"
    - Header section: Same dark navy `#1e2d5e` background with "ScienceOne" logo text
    - Heading: "Purchase Confirmed"
    - Body text: "Thank you for your purchase. You now have full digital access to:"
    - Book title: Bold, slightly larger (fontSize 18px)
    - Price and date: "Amount: ${amount.toFixed(2)} USD" and "Date: {formatted date}" in small text
    - CTA button: "Start Reading" linking to `{appUrl}/read/{bookSlug}` — same `#1e2d5e` button style
    - Download note (LOCKED DECISION: include download reminder): "PDF and EPUB downloads will be available soon. We'll notify you when they're ready." in small/muted text
    - Footer: Same as verification email (copyright + tagline)

    Export both named (`PurchaseConfirmationEmail`) and default.

    **2. Create `src/app/api/webhooks/stripe/route.ts` — webhook handler:**

    Import `stripe` from `@/lib/stripe`, `prisma` from `@/lib/prisma`, `Resend` from `resend`, `PurchaseConfirmationEmail` from `@/emails/PurchaseConfirmation`.
    Import `Stripe` type from `stripe` (for `Stripe.Event` type).

    Initialize Resend: `const resend = new Resend(process.env.RESEND_API_KEY)`.
    Read webhook secret: `const webhookSecret = process.env.STRIPE_WEBHOOK_SECRET!`.

    Export `async function POST(request: Request)`:
    - Read raw body: `const body = await request.text()` — CRITICAL: must use `text()` not `json()`, otherwise Stripe signature verification fails
    - Read signature: `const sig = request.headers.get("stripe-signature")`
    - If no sig, return `Response.json({ error: "Missing signature" }, { status: 400 })`
    - Construct event in try/catch: `stripe.webhooks.constructEvent(body, sig, webhookSecret)` — on error, return 400
    - Check `event.type === "checkout.session.completed"`
    - Cast: `const session = event.data.object as Stripe.Checkout.Session`
    - Check `session.payment_status === "paid"` — if not, return `{ received: true }` (async payment methods wait for separate event)
    - Extract metadata: `const { userId, bookId, bookSlug, userEmail } = session.metadata ?? {}`
    - If `!userId || !bookId`, return 400 with "Missing metadata"
    - Idempotent upsert: `prisma.purchase.upsert({ where: { userId_bookId: { userId, bookId } }, create: { userId, bookId, stripePaymentId: (session.payment_intent as string) ?? session.id, amount: (session.amount_total ?? 0) / 100, currency: session.currency ?? "usd", status: "completed" }, update: { status: "completed" } })`
    - Send receipt email (fire-and-forget with `void`): Fetch book title from DB (`prisma.book.findUnique` with `select: { title: true, slug: true }`). If book and userEmail exist, call `void resend.emails.send({ from: "ScienceOne <noreply@scienceone.com>", to: userEmail, subject: \`Your ScienceOne purchase: ${book.title}\`, react: PurchaseConfirmationEmail({ bookTitle: book.title, bookSlug: book.slug ?? bookSlug!, amount: (session.amount_total ?? 0) / 100, purchaseDate: new Date(), appUrl: process.env.NEXT_PUBLIC_APP_URL! }) })`
    - Return `Response.json({ received: true })` at end of handler (outside the event type check — Stripe sends many event types, always acknowledge)
  </action>
  <verify>
    1. `npm run build` completes without type errors
    2. `grep -r "request.text()" src/app/api/webhooks/stripe/route.ts` confirms raw body reading (not json())
    3. `grep -r "prisma.purchase.upsert" src/app/api/webhooks/stripe/route.ts` confirms idempotent upsert
    4. `grep -r "PurchaseConfirmationEmail" src/emails/PurchaseConfirmation.tsx` confirms email template exists
    5. `grep -r "resend.emails.send" src/app/api/webhooks/stripe/route.ts` confirms email sending
  </verify>
  <done>
    - Webhook handler at POST /api/webhooks/stripe reads raw body with request.text()
    - Stripe signature verified via stripe.webhooks.constructEvent()
    - checkout.session.completed event triggers idempotent Purchase upsert via @@unique([userId, bookId])
    - Duplicate webhooks do not create duplicate Purchase records
    - Purchase confirmation email sent via Resend with professional template matching VerificationEmail style
    - Email includes book title, price, purchase date, "Start Reading" link, and PDF/EPUB download reminder
    - Handler returns 200 for all valid Stripe events (not just checkout.session.completed)
  </done>
</task>

</tasks>

<verification>
1. `npm run build` passes — no type errors across all new files
2. Book detail page renders "Buy — $X.XX" for paid unauthenticated → "Sign In to Purchase" (verify by reading page.tsx)
3. Book detail page renders "Read Free" for open-access books (verify by reading page.tsx)
4. Webhook handler uses `request.text()` not `request.json()` (critical for Stripe signature)
5. Purchase upsert uses `userId_bookId` unique constraint for idempotency
6. Email template follows same style system as verification.tsx (header color #1e2d5e, same fonts)
7. Success page retrieves Stripe session and shows "Start Reading" link to `/read/{bookSlug}`
</verification>

<success_criteria>
- Stripe checkout flow is complete: Buy button -> Server Action -> Stripe-hosted checkout -> success page
- Webhook handler grants access via idempotent Purchase upsert — never via redirect
- Purchase confirmation email sent with book title, price, date, reading link, and download reminder
- Open-access books remain freely readable with "Read Free" CTA on detail page
- All code builds without errors
</success_criteria>

<output>
After completion, create `.planning/phases/05-payments-and-entitlement/05-01-SUMMARY.md`
</output>
