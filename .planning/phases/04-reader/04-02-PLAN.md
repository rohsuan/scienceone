---
phase: 04-reader
plan: 02
type: execute
wave: 2
depends_on: [04-01]
files_modified:
  - src/app/api/reading-progress/route.ts
  - src/components/reader/ScrollProgressTracker.tsx
  - src/components/reader/ReadingProgressBar.tsx
  - src/app/(reader)/read/[bookSlug]/page.tsx
  - src/app/(reader)/read/[bookSlug]/[chapterSlug]/page.tsx
  - src/lib/reader-queries.ts
autonomous: false
requirements: [READ-04]

must_haves:
  truths:
    - "Authenticated user's reading progress (chapter + scroll position) is saved to the database while reading"
    - "When an authenticated user returns to a book, they are redirected to their last chapter and scroll position is restored"
    - "Anonymous users on open-access books do NOT get progress persistence — they always start at chapter 1"
    - "Progress saves are debounced (2s) to prevent excessive API calls during scrolling"
    - "A thin progress bar at the top of the content area shows the user's scroll position within the current chapter"
  artifacts:
    - path: "src/app/api/reading-progress/route.ts"
      provides: "PATCH handler to save progress, GET handler to load progress"
      exports: ["PATCH", "GET"]
    - path: "src/components/reader/ScrollProgressTracker.tsx"
      provides: "Client component that tracks scroll position and saves via debounced PATCH"
    - path: "src/components/reader/ReadingProgressBar.tsx"
      provides: "Thin visual progress bar tracking scroll percentage"
    - path: "src/lib/reader-queries.ts"
      provides: "getReadingProgress(userId, bookId) query helper"
  key_links:
    - from: "src/components/reader/ScrollProgressTracker.tsx"
      to: "src/app/api/reading-progress/route.ts"
      via: "fetch PATCH /api/reading-progress with debounced scroll data"
      pattern: "fetch.*api/reading-progress.*PATCH"
    - from: "src/app/api/reading-progress/route.ts"
      to: "prisma.readingProgress.upsert"
      via: "Prisma upsert with userId_bookId compound unique"
      pattern: "prisma\\.readingProgress\\.upsert"
    - from: "src/app/(reader)/read/[bookSlug]/page.tsx"
      to: "src/lib/reader-queries.ts"
      via: "getReadingProgress to determine last chapter for redirect"
      pattern: "getReadingProgress"
    - from: "src/app/(reader)/read/[bookSlug]/[chapterSlug]/page.tsx"
      to: "src/components/reader/ScrollProgressTracker.tsx"
      via: "Renders ScrollProgressTracker with key={chapter.id} for fresh mount on chapter change"
      pattern: "ScrollProgressTracker.*key="
---

<objective>
Add reading progress persistence: save authenticated users' reading position (chapter + scroll) to the database, restore it when they return, and show a visual progress indicator.

Purpose: Users can leave and come back to find their book open to exactly where they stopped reading — the final piece of the reader experience that makes it feel like a real book.

Output: Reading progress API, scroll tracker, progress bar, and resume redirect logic.
</objective>

<execution_context>
@/Users/roh/.claude/get-shit-done/workflows/execute-plan.md
@/Users/roh/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-reader/04-RESEARCH.md
@.planning/phases/04-reader/04-01-SUMMARY.md
@src/lib/reader-queries.ts
@src/app/(reader)/read/[bookSlug]/page.tsx
@src/app/(reader)/read/[bookSlug]/[chapterSlug]/page.tsx
@prisma/schema.prisma
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create reading progress API, scroll tracker, progress bar, and integrate with reader pages</name>
  <files>
    src/app/api/reading-progress/route.ts
    src/components/reader/ScrollProgressTracker.tsx
    src/components/reader/ReadingProgressBar.tsx
    src/lib/reader-queries.ts
    src/app/(reader)/read/[bookSlug]/page.tsx
    src/app/(reader)/read/[bookSlug]/[chapterSlug]/page.tsx
  </files>
  <action>
    **Step 1: Add getReadingProgress to reader-queries.ts**

    Add to `src/lib/reader-queries.ts`:
    ```typescript
    export const getReadingProgress = cache(async (userId: string, bookId: string) => {
      return prisma.readingProgress.findUnique({
        where: { userId_bookId: { userId, bookId } },
      });
    });
    ```

    **Step 2: Create the reading progress API route handler**

    Create `src/app/api/reading-progress/route.ts`:

    **PATCH handler** (save progress):
    - Get session via `auth.api.getSession({ headers: await headers() })`. Return 401 if no session.
    - Parse request body: `{ bookId: string, chapterId: string, scrollPercent: number }`
    - Validate: bookId and chapterId are non-empty strings, scrollPercent is 0-100 integer
    - Use `prisma.readingProgress.upsert`:
      - where: `{ userId_bookId: { userId: session.user.id, bookId } }`
      - update: `{ chapterId, scrollPercent, updatedAt: new Date() }`
      - create: `{ userId: session.user.id, bookId, chapterId, scrollPercent }`
    - Return `Response.json({ ok: true })`

    **GET handler** (load progress):
    - Get session. Return `Response.json(null)` if no session.
    - Read `bookId` from URL search params. Return `Response.json(null)` if missing.
    - Query `prisma.readingProgress.findUnique` with compound key.
    - Return `Response.json(progress)` (or null).

    **Step 3: Create ScrollProgressTracker (client component)**

    Create `src/components/reader/ScrollProgressTracker.tsx`:
    - "use client"
    - Props: `bookId: string`, `chapterId: string`, `isAuthenticated: boolean`, `initialScrollPercent?: number`
    - Import `useDebouncedCallback` from "use-debounce"

    **Scroll position restore on mount:**
    ```typescript
    useEffect(() => {
      if (initialScrollPercent && initialScrollPercent > 0) {
        // Small delay to let content render before scrolling
        const timer = setTimeout(() => {
          const el = document.getElementById("reader-content");
          if (el) {
            el.scrollTop = (el.scrollHeight * initialScrollPercent) / 100;
          }
        }, 100);
        return () => clearTimeout(timer);
      }
    }, []); // Only on mount — key prop forces remount on chapter change
    ```

    **Debounced progress save:**
    ```typescript
    const saveProgress = useDebouncedCallback(async (percent: number) => {
      if (!isAuthenticated) return;
      await fetch("/api/reading-progress", {
        method: "PATCH",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ bookId, chapterId, scrollPercent: Math.round(percent) }),
      });
    }, 2000); // 2-second debounce
    ```

    **Scroll event listener:**
    ```typescript
    useEffect(() => {
      if (!isAuthenticated) return;
      const el = document.getElementById("reader-content");
      if (!el) return;

      const handleScroll = () => {
        const percent = (el.scrollTop / (el.scrollHeight - el.clientHeight)) * 100;
        saveProgress(Math.min(100, Math.max(0, percent)));
      };

      el.addEventListener("scroll", handleScroll, { passive: true });
      return () => el.removeEventListener("scroll", handleScroll);
    }, [isAuthenticated, saveProgress]);
    ```

    Return `null` — this is a purely behavioral component.

    **Step 4: Create ReadingProgressBar (client component)**

    Create `src/components/reader/ReadingProgressBar.tsx`:
    - "use client"
    - No props needed — reads scroll from the `#reader-content` element directly
    - State: `const [progress, setProgress] = useState(0)`
    - Attach scroll listener to `#reader-content` (same element as ScrollProgressTracker)
    - Render a thin bar at the top:
      ```tsx
      <div className="h-0.5 bg-muted w-full fixed top-12 left-0 lg:left-64 xl:left-72 right-0 z-10">
        <div
          className="h-full bg-primary transition-[width] duration-150 ease-out"
          style={{ width: `${progress}%` }}
        />
      </div>
      ```
    - The bar is positioned below the top bar (h-12 = top-12) and accounts for sidebar width on desktop

    **Step 5: Update book entry page with resume logic**

    Modify `src/app/(reader)/read/[bookSlug]/page.tsx` (created in Plan 01):
    - Add session check via `auth.api.getSession({ headers: await headers() })`
    - If authenticated, call `getReadingProgress(session.user.id, book.id)`
    - If progress exists, find the saved chapter in the chapters array by matching `progress.chapterId`
    - If found, redirect to that chapter slug instead of chapter 1
    - If no progress or not authenticated, redirect to first chapter (existing behavior)
    - Anonymous users always get chapter 1 (per locked decision: "Anonymous users reading open-access books do NOT get progress persistence")

    **Step 6: Update chapter page to render ScrollProgressTracker and ReadingProgressBar**

    Modify `src/app/(reader)/read/[bookSlug]/[chapterSlug]/page.tsx` (created in Plan 01):
    - After access control check, load reading progress for authenticated users:
      ```typescript
      let scrollPercent: number | undefined;
      if (session) {
        const progress = await getReadingProgress(session.user.id, chapter.book.id);
        // Only restore scroll if we're on the saved chapter
        if (progress && progress.chapterId === chapter.id) {
          scrollPercent = progress.scrollPercent;
        }
      }
      ```
    - Add `ScrollProgressTracker` at the bottom of the page return, BEFORE the closing `</div>`:
      ```tsx
      <ScrollProgressTracker
        key={chapter.id}
        bookId={chapter.book.id}
        chapterId={chapter.id}
        isAuthenticated={!!session}
        initialScrollPercent={scrollPercent}
      />
      <ReadingProgressBar />
      ```
    - The `key={chapter.id}` forces a fresh mount on chapter change, preventing stale scroll restoration

    **IMPORTANT implementation notes:**
    - The `ReadingProgress` model in schema.prisma already has `@@unique([userId, bookId])` — Prisma generates the compound unique name as `userId_bookId`
    - The scroll listener attaches to `#reader-content` (the `<main>` element in the book-level layout) — NOT `window` or `document.body`
    - `initialScrollPercent` should only be set when the chapter being viewed matches the saved progress chapter — do NOT restore scroll on a different chapter
    - Progress saves only happen for authenticated users (`isAuthenticated` check in both the scroll handler and the API route)
    - `useDebouncedCallback` from "use-debounce" (already in package.json) handles cleanup automatically
    - Silent resume: no toast notification on progress restore (per research recommendation)
  </action>
  <verify>
    1. Run `npx tsc --noEmit` — no type errors
    2. Run `npm run build` — build succeeds
    3. Verify API route: `ls src/app/api/reading-progress/route.ts` exists
    4. Grep for upsert: `grep "upsert" src/app/api/reading-progress/route.ts` returns match
    5. Grep for debounce: `grep "useDebouncedCallback" src/components/reader/ScrollProgressTracker.tsx` returns match
    6. Grep for resume: `grep "getReadingProgress" src/app/\(reader\)/read/\[bookSlug\]/page.tsx` returns match
    7. Grep for key prop: `grep "key={chapter.id}" src/app/\(reader\)/read/\[bookSlug\]/\[chapterSlug\]/page.tsx` returns match
  </verify>
  <done>
    Reading progress API (PATCH + GET) persists chapter and scroll position for authenticated users via Prisma upsert. ScrollProgressTracker debounces scroll events at 2s intervals and silently restores scroll position on mount. ReadingProgressBar shows a thin visual indicator of scroll progress. Book entry page redirects authenticated users to their last chapter. Anonymous users always start at chapter 1 with no progress tracking.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 2: Verify complete reader experience</name>
  <files>none — verification only</files>
  <action>
Human verifies the complete browser reader experience built in Plans 04-01 and 04-02.

**What was built:** Browser reader with chapter rendering, KaTeX math display, ToC sidebar navigation, mobile responsive layout, prev/next chapter navigation, and reading progress persistence.

**How to verify:**

Use Rodney to test on a browser:

1. **Reader access:** Navigate to `/read/{any-published-book-slug}` — should redirect to first chapter (or last read chapter if logged in)

2. **Chapter rendering:** Verify the chapter content displays with correctly rendered mathematical formulas (KaTeX) — equations should appear styled, not as raw LaTeX or unstyled HTML

3. **ToC sidebar (desktop):** On desktop viewport (1024px+), the left sidebar should show all chapters. The current chapter should be highlighted with a primary color tint. Clicking a different chapter should navigate to it.

4. **ToC drawer (mobile):** Resize to 375px width. The sidebar should be hidden. Tap the hamburger menu icon in the top bar — a Sheet drawer should slide in from the left showing the chapter list. Selecting a chapter should close the drawer and navigate.

5. **Prev/next navigation:** At the bottom of a chapter, verify prev/next links show the correct chapter titles. On the first chapter, only "Next" should appear. On the last chapter, only "Previous."

6. **Math overflow:** If a chapter has wide display equations, verify they scroll horizontally without a vertical scrollbar appearing (the double-scrollbar bug fix).

7. **Reading progress (if logged in):**
   - Read partway through a chapter, then navigate away from the reader
   - Return to `/read/{book-slug}` — should redirect to the last chapter you were reading
   - Scroll position should restore approximately to where you left off
   - Check the thin progress bar at the top of the content area tracks scroll position

8. **Access control:** Try navigating to `/read/{paid-book-slug}/{non-preview-chapter}` without purchasing — should redirect to the catalog detail page

9. **Anonymous access:** Open an open-access book in an incognito/private window — should be fully readable without login. No progress bar tracking or resume behavior.
  </action>
  <verify>User confirms all 9 verification checks pass, or describes specific issues.</verify>
  <done>Complete reader experience verified: chapter rendering with math, ToC navigation, mobile responsiveness, access control, and reading progress persistence all working correctly.</done>
</task>

</tasks>

<verification>
1. `npm run build` completes without errors
2. Reading progress persists across sessions for authenticated users
3. Anonymous users have no progress tracking
4. Resume redirect works: authenticated users return to their last chapter
5. Progress bar visually tracks scroll position
6. Debounced saves prevent excessive API calls (2s interval)
7. Chapter key prop ensures fresh mount on navigation (no stale scroll)
</verification>

<success_criteria>
- Authenticated users' reading progress is saved and restored across sessions
- Book entry page redirects to last-read chapter for authenticated users
- Scroll position within a chapter is restored on return
- Anonymous users on open-access books start at chapter 1 with no persistence
- Visual progress bar tracks scroll percentage within current chapter
- Progress saves are debounced at 2-second intervals
</success_criteria>

<output>
After completion, create `.planning/phases/04-reader/04-02-SUMMARY.md`
</output>
