---
phase: 02-ingest
plan: "01"
type: execute
wave: 1
depends_on: []
files_modified:
  - prisma/schema.prisma
  - scripts/lib/pandoc.ts
  - scripts/lib/katex-render.ts
  - scripts/lib/chapter-split.ts
  - scripts/lib/health-report.ts
  - package.json
autonomous: true
requirements: [ADM-01, ADM-02]

must_haves:
  truths:
    - "Pandoc CLI can be invoked from TypeScript and returns stdout/stderr with proper error handling"
    - "KaTeX pre-renders inline and display math from Pandoc HTML output into static HTML requiring no client-side JavaScript"
    - "Full-document HTML is split into individual chapter objects by h1 headings with position indices"
    - "Health report collects Pandoc warnings, broken equations, and unsupported commands and halts on errors"
    - "Book model has pdfKey and epubKey fields for R2 storage references"
  artifacts:
    - path: "scripts/lib/pandoc.ts"
      provides: "Typed async wrapper around child_process.spawn for Pandoc CLI invocation"
      exports: ["runPandoc"]
    - path: "scripts/lib/katex-render.ts"
      provides: "Post-processing of Pandoc HTML to replace math spans with pre-rendered KaTeX HTML"
      exports: ["preRenderMath"]
    - path: "scripts/lib/chapter-split.ts"
      provides: "Split full-document HTML into chapter objects by h1 headings"
      exports: ["splitChapters"]
    - path: "scripts/lib/health-report.ts"
      provides: "Structured health report collecting pipeline warnings and errors"
      exports: ["HealthReport", "buildHealthReport", "printHealthReport"]
    - path: "prisma/schema.prisma"
      provides: "Book model with pdfKey and epubKey String? fields"
      contains: "pdfKey"
  key_links:
    - from: "scripts/lib/katex-render.ts"
      to: "katex"
      via: "katex.renderToString"
      pattern: "katex\\.renderToString"
    - from: "scripts/lib/katex-render.ts"
      to: "cheerio"
      via: "cheerio.load and jQuery-like selectors"
      pattern: "cheerio\\.load"
    - from: "scripts/lib/pandoc.ts"
      to: "child_process"
      via: "spawn('pandoc', args)"
      pattern: "spawn\\('pandoc'"
    - from: "scripts/lib/chapter-split.ts"
      to: "cheerio"
      via: "cheerio.load for DOM traversal"
      pattern: "cheerio\\.load"
---

<objective>
Build the core manuscript conversion pipeline modules: Pandoc invocation wrapper, KaTeX server-side math pre-rendering, chapter splitting, and health reporting. Add PDF/EPUB storage key fields to the Book model.

Purpose: These modules form the conversion engine that transforms LaTeX, Word, and Markdown manuscripts into pre-rendered HTML chapters. Every other part of the ingest pipeline depends on these building blocks.

Output: Four TypeScript modules in scripts/lib/, updated Prisma schema with pdfKey/epubKey, migration applied, all npm dependencies installed.
</objective>

<execution_context>
@/Users/roh/.claude/get-shit-done/workflows/execute-plan.md
@/Users/roh/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-ingest/02-RESEARCH.md
@prisma/schema.prisma
@src/lib/prisma.ts
@package.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install dependencies and add artifact storage fields to Book model</name>
  <files>
    package.json
    prisma/schema.prisma
  </files>
  <action>
    1. Install npm dependencies:
       ```bash
       npm install katex cheerio commander @aws-sdk/client-s3 @aws-sdk/lib-storage @aws-sdk/s3-request-presigner chalk
       npm install --save-dev @types/katex
       ```

    2. Verify Pandoc is installed on the system:
       ```bash
       pandoc --version
       ```
       If not installed, print a clear message: "Pandoc is required. Install with: brew install pandoc"
       Do NOT attempt to install it — just verify and warn.

    3. Add `pdfKey` and `epubKey` fields to the Book model in `prisma/schema.prisma`:
       ```prisma
       model Book {
         // ... existing fields after downloads relation ...
         pdfKey    String?   // R2 storage key: "books/{slug}/{slug}.pdf"
         epubKey   String?   // R2 storage key: "books/{slug}/{slug}.epub"
         // ... rest unchanged ...
       }
       ```
       Add these two fields AFTER the existing `downloads` relation and BEFORE `@@map("books")`. Do NOT modify any other model or field.

    4. Run Prisma migration:
       ```bash
       npx prisma migrate dev --name add_book_artifact_keys
       ```
       If PostgreSQL is not running, this will fail — that is expected and documented in STATE.md blockers. Create the migration file regardless by running:
       ```bash
       npx prisma migrate dev --name add_book_artifact_keys --create-only
       ```
       This creates the migration SQL without applying it.

    5. Regenerate the Prisma client:
       ```bash
       npx prisma generate
       ```

    6. Add R2 env vars to `.env.example` (append, do not modify existing lines):
       ```
       R2_ACCOUNT_ID=your-r2-account-id
       R2_ACCESS_KEY_ID=your-r2-access-key-id
       R2_SECRET_ACCESS_KEY=your-r2-secret-access-key
       R2_BUCKET_NAME=scienceone
       ```

    7. Create the `scripts/lib/` directory structure:
       ```bash
       mkdir -p scripts/lib
       ```
  </action>
  <verify>
    - `npm ls katex cheerio commander @aws-sdk/client-s3 chalk` — all listed without errors
    - `npx prisma generate` succeeds
    - `ls prisma/migrations/` shows the new migration directory
    - `grep "pdfKey" prisma/schema.prisma` returns the field definition
    - `grep "R2_ACCOUNT_ID" .env.example` returns the new env var
    - `ls scripts/lib/` directory exists
  </verify>
  <done>
    All npm dependencies installed. Book model has pdfKey and epubKey fields. Migration file created. Prisma client regenerated. R2 env vars documented in .env.example. scripts/lib/ directory exists.
  </done>
</task>

<task type="auto">
  <name>Task 2: Build Pandoc wrapper, KaTeX renderer, chapter splitter, and health report modules</name>
  <files>
    scripts/lib/pandoc.ts
    scripts/lib/katex-render.ts
    scripts/lib/chapter-split.ts
    scripts/lib/health-report.ts
  </files>
  <action>
    **scripts/lib/pandoc.ts — Pandoc invocation wrapper**

    Create an async function `runPandoc(args: string[], cwd?: string)` that:
    - Spawns `pandoc` via `child_process.spawn` with the given args array
    - Sets `cwd` to the provided directory (important for LaTeX `\input`/`\include` resolution — see Research Pitfall 5)
    - Collects stdout and stderr as strings
    - Returns `{ stdout: string; stderr: string }` on success (exit code 0)
    - Throws an Error with stderr content on non-zero exit code
    - NEVER shell-interpolates user paths — always pass as array arguments to spawn

    Export a helper `detectFormat(filePath: string): 'latex' | 'docx' | 'markdown'` that maps file extensions:
    - `.tex` → `'latex'`
    - `.docx` → `'docx'`
    - `.md`, `.markdown` → `'markdown'`
    - Throws for unsupported extensions

    Export `convertToHtml(inputFile: string, format: string): Promise<{ html: string; stderr: string }>` that:
    - Resolves inputFile to absolute path
    - Sets cwd to `path.dirname(path.resolve(inputFile))`
    - Calls runPandoc with format-specific args:
      - latex: `['-f', 'latex+raw_tex', '-t', 'html5', '--no-highlight', path.basename(inputFile)]`
      - docx: `['-f', 'docx', '-t', 'html5', '--extract-media', './media', path.basename(inputFile)]`
      - markdown: `['-f', 'markdown', '-t', 'html5', path.basename(inputFile)]`
    - Returns raw HTML string and stderr warnings
    - Do NOT use `-s` (standalone) flag — we want HTML fragments, not full documents

    Export `convertToPdf(inputFile: string): Promise<{ outputPath: string; stderr: string }>` that:
    - Creates output path as `{inputDir}/{basename}.pdf`
    - Calls runPandoc: `['-f', detectFormat(inputFile), '--pdf-engine=xelatex', '--pdf-engine-opt=-halt-on-error', inputFile, '-o', outputPath]`
    - Returns the output file path

    Export `convertToEpub(inputFile: string): Promise<{ outputPath: string; stderr: string }>` that:
    - Creates output path as `{inputDir}/{basename}.epub`
    - Calls runPandoc: `['-f', detectFormat(inputFile), '-t', 'epub3', '--toc', '--toc-depth=2', inputFile, '-o', outputPath]`
    - Returns the output file path

    **scripts/lib/katex-render.ts — KaTeX post-processing**

    Create `preRenderMath(html: string, errors: string[]): string` that:
    - Loads HTML with `cheerio.load(html, { xmlMode: false })`
    - Finds all `span.math.inline` elements, extracts their text content (raw LaTeX), calls `katex.renderToString(tex, { displayMode: false, throwOnError: true, output: 'html' })`, and replaces the span with the rendered output
    - Finds all `span.math.display` elements, same process but with `displayMode: true`
    - On KaTeX error: push error message to the `errors` array, replace the element with `<span class="math-error" data-latex="...">[MATH ERROR]</span>` (inline) or `<div class="math-error" data-latex="...">[MATH ERROR]</div>` (display)
    - Returns the processed HTML string via `$.html()`
    - Import katex as `import katex from 'katex'` and cheerio as `import * as cheerio from 'cheerio'`

    **scripts/lib/chapter-split.ts — Chapter splitting by h1**

    Create a `Chapter` interface: `{ title: string; slug: string; content: string; position: number }`

    Create `splitChapters(html: string): Chapter[]` that:
    - Loads HTML with `cheerio.load(html)`
    - Iterates over each `h1` element
    - For each h1: collects its text as `title`, generates a slug (lowercase, replace spaces/non-alphanumeric with hyphens, trim hyphens), collects the h1 element HTML plus all following sibling elements until the next h1 into `content`, assigns incrementing `position` starting at 0
    - If no h1 elements found, returns a single chapter with title "Chapter 1", the full HTML as content, position 0
    - Returns the array of Chapter objects

    Implement `slugify(text: string): string` as a local helper — lowercase, replace non-alphanumeric with hyphens, collapse consecutive hyphens, trim leading/trailing hyphens.

    **scripts/lib/health-report.ts — Health report**

    Define the `HealthReport` interface:
    ```typescript
    interface HealthReport {
      inputFile: string;
      format: string;
      pandocWarnings: string[];
      mathErrors: string[];
      unsupportedCommands: string[];
      chapterCount: number;
      halted: boolean;
    }
    ```

    Create `buildHealthReport(inputFile: string, format: string, pandocStderr: string, mathErrors: string[], chapterCount: number): HealthReport` that:
    - Parses pandocStderr line-by-line
    - Lines containing `[WARNING]` or non-empty → pandocWarnings
    - Lines containing `unknown` or `not supported` (case-insensitive) → unsupportedCommands
    - Sets `halted = true` if mathErrors.length > 0 OR unsupportedCommands.length > 0
    - Returns the HealthReport object

    Create `printHealthReport(report: HealthReport): void` that:
    - Uses chalk to colorize output
    - Prints header: "=== Ingest Health Report ==="
    - Prints input file and format
    - Prints chapter count
    - Prints pandocWarnings in yellow (if any)
    - Prints mathErrors in red (if any)
    - Prints unsupportedCommands in red (if any)
    - If halted: prints bold red "HALTED: Pipeline stopped due to errors above"
    - If not halted and no warnings: prints green "OK: No issues detected"
    - If not halted but has warnings: prints yellow "PASSED WITH WARNINGS"

    All modules must use ES module imports (import/export, not require) and be compatible with tsx execution.
  </action>
  <verify>
    - `npx tsx -e "import { runPandoc, detectFormat, convertToHtml } from './scripts/lib/pandoc'; console.log(detectFormat('test.tex'))"` prints `latex`
    - `npx tsx -e "import { preRenderMath } from './scripts/lib/katex-render'; const e: string[] = []; const r = preRenderMath('<span class=\"math inline\">x^2</span>', e); console.log(r.includes('katex'), e.length === 0)"` prints `true true`
    - `npx tsx -e "import { splitChapters } from './scripts/lib/chapter-split'; const c = splitChapters('<h1>Ch 1</h1><p>text</p><h1>Ch 2</h1><p>more</p>'); console.log(c.length, c[0].title, c[1].position)"` prints `2 Ch 1 1`
    - `npx tsx -e "import { buildHealthReport } from './scripts/lib/health-report'; const r = buildHealthReport('t.tex', 'latex', '', ['broken eq'], 3); console.log(r.halted, r.mathErrors.length)"` prints `true 1`
    - All four files exist in `scripts/lib/` and have no TypeScript compilation errors: `npx tsx --tsconfig tsconfig.json -e "import './scripts/lib/pandoc'; import './scripts/lib/katex-render'; import './scripts/lib/chapter-split'; import './scripts/lib/health-report'; console.log('OK')"`
  </verify>
  <done>
    Four pipeline modules exist in scripts/lib/ and are importable via tsx. pandoc.ts can invoke Pandoc for all three formats. katex-render.ts pre-renders inline and display math. chapter-split.ts splits HTML by h1. health-report.ts builds and prints a colored health report that halts on errors.
  </done>
</task>

</tasks>

<verification>
1. All npm dependencies installed: katex, cheerio, commander, @aws-sdk/client-s3, @aws-sdk/lib-storage, @aws-sdk/s3-request-presigner, chalk, @types/katex
2. prisma/schema.prisma has pdfKey and epubKey on Book model
3. Migration file exists in prisma/migrations/
4. Prisma client regenerated successfully
5. Four modules in scripts/lib/ all import cleanly via tsx
6. katex-render.ts produces pre-rendered HTML (contains "katex" class) from math spans
7. chapter-split.ts splits by h1 and produces position-indexed chapters
8. health-report.ts halts when math errors or unsupported commands are present
</verification>

<success_criteria>
- `npm ls katex cheerio commander @aws-sdk/client-s3 chalk` exits 0
- `grep pdfKey prisma/schema.prisma` shows the field
- All four scripts/lib/ modules import without TypeScript errors via tsx
- KaTeX pre-rendering converts `<span class="math inline">x^2</span>` into rendered HTML containing katex CSS classes
- Chapter splitting on HTML with two h1 elements produces a 2-element array
- Health report with math errors sets halted=true
</success_criteria>

<output>
After completion, create `.planning/phases/02-ingest/02-01-SUMMARY.md`
</output>
